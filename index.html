<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Match 3 with VK Login</title>
  <script src="https://vk.com/js/api/openapi.js?169"></script>
  <style>
    @font-face {
      font-family: 'Curse Casual';
      src: url('fonts/CurseCasual.ttf') format('truetype'); /* Путь к вашему файлу шрифта */
    }

    body {
      background: linear-gradient(to bottom, #ADD8E6, #87CEEB); /* Голубо-синий градиент */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      font-family: 'Curse Casual', sans-serif; /* Используем шрифт Curse Casual */
      overflow: hidden;
      color: white; /* Белый цвет текста по умолчанию */
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #gameBoard {
      display: grid;
      grid-gap: 2px;
      border: 1px solid black;
      width: 1100px;
      height: 1100px;
      background-color: #77B5FE; /* Цвет морской волны */
      border-radius: 20px; /* Скругленные углы для игрового поля */
      overflow: hidden; /* Обрезаем все, что выходит за границы скругленных углов */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Небольшая тень для глубины */
    }

    .cell {
      width: 135px; /* Подгоняем размер ячеек */
      height: 135px;
      text-align: center;
      font-size: 24px;
      cursor: pointer;
      transition: transform 0.2s ease, background-color 0.2s ease;
      background-size: contain; /* Масштабируем спрайт, чтобы он полностью поместился в ячейку */
      background-repeat: no-repeat;
      background-position: center;
      border-radius: 15px; /* Скругленные углы для ячеек */
      background-color: #6495ED; /* Более темный цвет морской волны для ячеек */
    }

    .cell.swapping {
      transform: scale(1.2);
    }

    .cell.removing {
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    #loginBtn { /* Заменили #startBtn на #loginBtn */
      padding: 20px 40px;
      font-size: 24px;
      cursor: pointer;
      background-color: #4682B4; /* Steel Blue */
      color: white;
      border: none;
      border-radius: 10px;
      transition: background-color 0.3s ease;
      position: absolute; /* Центрируем кнопку абсолютно */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100; /* Кнопка поверх всего */
    }

    #loginBtn:hover {
      background-color: #5F9EA0; /* Cadet Blue */
    }

    #userInfo {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 16px;
    }

    #userInfo img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin-right: 10px;
      vertical-align: middle;
    }

  </style>
</head>
<body>

  <div id="gameContainer">
    <button id="loginBtn">Start Game / Login with VK</button>
    <div id="gameBoard"></div>
    <div id="userInfo" style="display: none;"></div>
  </div>

  <script>
    // VK API ID
    const vkApiId = 8109529; // Замени на реальный ID приложения

    const boardWidth = 8;
    const boardHeight = 8;
    const colors = [
      'img/red.png',
      'img/blue.png',
      'img/green.png',
      'img/yellow.png',
      'img/purple.png',
      'img/white.png'
    ];
    let gameBoard = [];
    let selectedCell = null;
    const loginBtn = document.getElementById('loginBtn'); // Переименовано
    const gameBoardDiv = document.getElementById('gameBoard');
    const userInfoDiv = document.getElementById('userInfo');

    const spriteSize = 135;

    // Инициализация VK SDK
    VK.init({
      apiId: vkApiId
    });

    let gameStarted = false;

    // Функция для запуска игры
    function startGame() {
      gameStarted = true;
      initializeBoard();
      renderBoard();
      // Скрыть кнопку
      loginBtn.style.display = 'none';
    }


    // Авторизация через VK
    loginBtn.addEventListener('click', () => {
      VK.Auth.login(response => {
        if (response.session) {
          console.log('Успешный вход:', response);
          // Получаем ID пользователя
          const userId = response.session.mid;
          // Запрашиваем данные пользователя
          VK.Api.call('users.get', {
            user_ids: userId,
            fields: 'photo_200,city',
            v: '5.131'
          }, data => {
            if (data.response) {
              console.log('Данные пользователя:', data.response[0]);
              const user = data.response[0];
              displayUserInfo(user); // Отображаем информацию о пользователе
            } else {
              console.log('Ошибка получения данных пользователя:', data.error);
            }

            // Запускаем игру в любом случае, успешно или нет получили данные пользователя
             startGame();
          });
        } else {
          console.log('Ошибка авторизации');
          // Запускаем игру, даже если не удалось авторизоваться
          startGame();

        }
      }, 2); // 2 — права на доступ к стене
    });


    // Функция для отображения информации о пользователе
    function displayUserInfo(user) {
      userInfoDiv.innerHTML = `
        <img src="${user.photo_200}" alt="Фото">
        <span>${user.first_name} ${user.last_name}</span>
      `;
      userInfoDiv.style.display = 'block';
    }


    // Функция для создания случайного цвета
    function getRandomColor() {
      const randomIndex = Math.floor(Math.random() * colors.length);
      return `url(${colors[randomIndex]})`; // Возвращаем URL для background-image
    }

    // Функция для инициализации игрового поля
    function initializeBoard() {
      gameBoard = [];
      for (let row = 0; row < boardHeight; row++) {
        gameBoard[row] = [];
        for (let col = 0; col < boardWidth; col++) {
          let color;
          do {
            color = getRandomColor();
          } while (hasMatchAt(row, col, color));
          gameBoard[row][col] = color;
        }
      }
    }

    // Функция для проверки наличия совпадений при генерации
    function hasMatchAt(row, col, color) {
      if (col >= 2 && gameBoard[row][col - 1] === color && gameBoard[row][col - 2] === color) {
        return true;
      }
      if (row >= 2 && gameBoard[row - 1][col] === color && gameBoard[row - 2][col] === color) {
        return true;
      }
      return false;
    }

    // Функция для отрисовки игрового поля
    function renderBoard() {

      gameBoardDiv.innerHTML = '';

      gameBoardDiv.style.gridTemplateColumns = `repeat(${boardWidth}, 1fr)`;
      gameBoardDiv.style.gridTemplateRows = `repeat(${boardHeight}, 1fr)`; // Явно задаем grid-template-rows

      for (let row = 0; row < boardHeight; row++) {
        for (let col = 0; col < boardWidth; col++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.style.backgroundImage = gameBoard[row][col];
          cell.style.width = `${spriteSize}px`;  // Устанавливаем размер ячейки
          cell.style.height = `${spriteSize}px`; // Устанавливаем размер ячейки
          cell.addEventListener('click', handleCellClick);
          gameBoardDiv.appendChild(cell);
        }
      }
    }

    // Функция для обработки клика по ячейке
    async function handleCellClick(event) {
      if (!gameStarted) return;
      const row = parseInt(event.target.dataset.row);
      const col = parseInt(event.target.dataset.col);

      if (selectedCell === null) {
        selectedCell = { row, col };
      } else {
        const rowDiff = Math.abs(row - selectedCell.row);
        const colDiff = Math.abs(col - selectedCell.col);

        if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
          const cell1 = document.querySelector(`.cell[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
          const cell2 = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);

          // Анимация обмена
          cell1.classList.add('swapping');
          cell2.classList.add('swapping');

          // Пауза для анимации
          await delay(200);

          swapCells(selectedCell.row, selectedCell.col, row, col);
          renderBoard();

          cell1.classList.remove('swapping');
          cell2.classList.remove('swapping');

          if (findMatches()) {
            await handleMatches();
          } else {
            // Анимация отмены обмена
            cell1.classList.add('swapping');
            cell2.classList.add('swapping');

            // Пауза для анимации
            await delay(200);

            swapCells(selectedCell.row, selectedCell.col, row, col);
            renderBoard();

            cell1.classList.remove('swapping');
            cell2.classList.remove('swapping');
          }

        }

        selectedCell = null;
      }
    }

    // Функция задержки (для анимаций)
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Функция для обмена ячеек местами
    function swapCells(row1, col1, row2, col2) {
      const tempColor = gameBoard[row1][col1];
      gameBoard[row1][col1] = gameBoard[row2][col2];
      gameBoard[row2][col2] = tempColor;
    }

    // Функция для поиска совпадений
    function findMatches() {
      let matchesFound = false;
      let matches = [];

      // Проверка по горизонтали
      for (let row = 0; row < boardHeight; row++) {
        for (let col = 0; col < boardWidth - 2; col++) {
          const color = gameBoard[row][col];
          if (color && color === gameBoard[row][col + 1] && color === gameBoard[row][col + 2]) {
            matches.push({ row, col });
            matches.push({ row, col: col + 1 });
            matches.push({ row, col: col + 2 });
          }
        }
      }
    }

    // Функция для обработки и удаления совпадений (с анимацией)
    async function handleMatches() {
      let hasMatches;
      do {
        hasMatches = await removeMatchesWithAnimation();

        if (hasMatches) {
          dropCells();
          renderBoard();
        }
      } while (hasMatches && findMatches());
    }

    async function removeMatchesWithAnimation() {
      let matchesHorizontally = [];
      let matchesVertically = [];

      // Находим горизонтальные совпадения
      for (let row = 0; row < boardHeight; row++) {
        for (let col = 0; col < boardWidth - 2; col++) {
          const color = gameBoard[row][col];
          if (color === gameBoard[row][col + 1] && color === gameBoard[row][col + 2]) {
            matchesHorizontally.push({ row, col });
            matchesHorizontally.push({ row, col: col + 1 });
            matchesHorizontally.push({ row, col: col + 2 });
            col += 2;
          }
        }
      }
    }

    function dropCells() {
      for (let col = 0; col < boardWidth; col++) {
        let emptyRow = boardHeight - 1;

        for (let row = boardHeight - 1; row >= 0; row--) {
          if (gameBoard[row][col] !== null) {
            gameBoard[emptyRow][col] = gameBoard[row][col];
            if (row !== emptyRow) {
              gameBoard[row][col] = null;
            }
            emptyRow--;
          }
        }
      }
    }
  </script>
</body>
</html>